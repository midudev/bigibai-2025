---
import GameLayout from '@/components/games/GameLayout.astro'

export interface Props {
  day: number
  gameData?: {
    targetScore?: number
    prize?: string
    videoUrl?: string
  }
}

const { day, gameData } = Astro.props

const GAME_DATA = {
  day: day,
  targetScore: gameData?.targetScore || 1,
  prize: gameData?.prize || 'Premio del día',
  videoUrl: gameData?.videoUrl,
}
---

<GameLayout prize={GAME_DATA.prize} videoUrl={GAME_DATA.videoUrl}>
  <div id="pang-game-container" slot="game">
    <!-- UI Layer -->
    <div id="ui-layer">
      <span id="lives-display">❤❤❤</span>
      <span>NIVEL: <span id="level-display">1</span>/3</span>
    </div>

    <canvas id="pangCanvas"></canvas>

    <!-- Start Screen -->
    <div id="start-screen" class="modal active">
      <h1>GAFAS<br />PANG</h1>

      <div class="instructions">
        <p class="controls-title">CONTROLES</p>
        <p>MOVER: A/D o Flechas</p>
        <p>DISPARAR: Espacio o Click</p>
        <br />
        <p class="hint">¡Revienta las burbujas!</p>
        <p class="hint">Completa 3 niveles para ganar</p>
      </div>

      <button id="start-btn" class="menu-btn blink">EMPEZAR</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="modal hidden">
      <h1 class="danger">GAME OVER</h1>
      <p>Llegaste al nivel <span id="final-level">1</span></p>
      <button id="restart-btn" class="menu-btn">REINTENTAR</button>
    </div>

    <!-- Win Screen -->
    <div id="win-screen" class="modal hidden">
      <h1 class="win">¡GANASTE!</h1>
      <p>¡Has completado los 3 niveles!</p>
    </div>

    <!-- Game Boy Style Controls -->
    <div id="gameboy-controls">
      <!-- D-Pad -->
      <div class="dpad-wrapper">
        <div class="dpad">
          <div id="btn-left" class="dpad-btn dpad-left">
            <span class="dpad-arrow">◀</span>
          </div>
          <div class="dpad-center"></div>
          <div id="btn-right" class="dpad-btn dpad-right">
            <span class="dpad-arrow">▶</span>
          </div>
        </div>
        <div class="control-label">← MOVER →</div>
      </div>

      <!-- Action Buttons -->
      <div class="action-wrapper">
        <div class="action-buttons">
          <div id="btn-shoot" class="action-btn">
            <span class="btn-letter">A</span>
          </div>
        </div>
        <div class="control-label">DISPARAR</div>
      </div>
    </div>
  </div>
</GameLayout>

<style>
  @font-face {
    font-family: 'Press Start 2P';
    src: url('/fonts/press-start.woff2') format('woff2');
  }

  #pang-game-container {
    position: relative;
    width: 100%;
    height: 100%;
    background-color: #1a1a2e;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    font-family: 'Press Start 2P', cursive;
    color: #ffffff;
    user-select: none;
    -webkit-user-select: none;
    touch-action: none;
  }

  /* UI Layer */
  #ui-layer {
    position: absolute;
    top: 15px;
    left: 0;
    width: 100%;
    box-sizing: border-box;
    padding: 0 15px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    color: white;
    z-index: 5;
    text-shadow: 2px 2px 0 #000;
    font-size: 14px;
    pointer-events: none;
  }

  #lives-display {
    color: #e74c3c;
    letter-spacing: 2px;
  }

  /* Canvas */
  #pangCanvas {
    display: block;
    width: 100%;
    flex: 1;
    image-rendering: pixelated;
  }

  /* Game Boy Style Controls */
  #gameboy-controls {
    height: 130px;
    background: linear-gradient(to bottom, #2d2d3a 0%, #1f1f28 100%);
    border-top: 3px solid #444;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 20px;
    box-sizing: border-box;
    flex-shrink: 0;
  }

  .dpad-wrapper,
  .action-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
  }

  .control-label {
    font-size: 8px;
    color: #666;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  /* D-Pad */
  .dpad {
    display: flex;
    align-items: center;
    gap: 0;
  }

  .dpad-btn {
    width: 70px;
    height: 70px;
    background: linear-gradient(145deg, #3a3a4a, #28282f);
    border: 2px solid #222;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    transition: all 0.05s ease;
    position: relative;
  }

  .dpad-left {
    border-radius: 12px 0 0 12px;
    box-shadow:
      -3px 3px 0 #111,
      inset 2px 2px 4px rgba(255, 255, 255, 0.1);
  }

  .dpad-right {
    border-radius: 0 12px 12px 0;
    box-shadow:
      3px 3px 0 #111,
      inset 2px 2px 4px rgba(255, 255, 255, 0.1);
  }

  .dpad-center {
    width: 16px;
    height: 70px;
    background: linear-gradient(145deg, #3a3a4a, #28282f);
    border-top: 2px solid #222;
    border-bottom: 2px solid #222;
  }

  .dpad-arrow {
    font-size: 20px;
    color: #888;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
    pointer-events: none;
  }

  .dpad-btn:active,
  .dpad-btn.pressed {
    background: linear-gradient(145deg, #28282f, #1a1a22);
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
  }

  .dpad-btn:active .dpad-arrow,
  .dpad-btn.pressed .dpad-arrow {
    color: #4cd137;
    text-shadow: 0 0 8px rgba(76, 209, 55, 0.6);
  }

  /* Action Buttons */
  .action-buttons {
    display: flex;
    gap: 10px;
  }

  .action-btn {
    width: 60px;
    height: 60px;
    background: linear-gradient(145deg, #e74c3c, #c0392b);
    border: 3px solid #a93226;
    border-radius: 50%;
    box-shadow:
      0 4px 0 #7b241c,
      0 6px 10px rgba(0, 0, 0, 0.4),
      inset 0 -2px 10px rgba(0, 0, 0, 0.2),
      inset 0 2px 10px rgba(255, 255, 255, 0.2);
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: all 0.05s ease;
  }

  .btn-letter {
    font-size: 20px;
    font-weight: bold;
    color: rgba(255, 255, 255, 0.9);
    text-shadow:
      0 2px 2px rgba(0, 0, 0, 0.3),
      0 0 10px rgba(255, 255, 255, 0.2);
    pointer-events: none;
  }

  .action-btn:active,
  .action-btn.pressed {
    transform: translateY(4px);
    box-shadow:
      0 0 0 #7b241c,
      0 2px 5px rgba(0, 0, 0, 0.4),
      inset 0 2px 10px rgba(0, 0, 0, 0.4);
    background: linear-gradient(145deg, #c0392b, #a93226);
  }

  .action-btn:active .btn-letter,
  .action-btn.pressed .btn-letter {
    color: #fff;
    text-shadow:
      0 0 10px rgba(255, 255, 255, 0.8),
      0 0 20px rgba(255, 255, 255, 0.4);
  }

  /* Modals */
  .modal {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: calc(100% - 130px);
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 20;
    color: white;
    text-align: center;
  }

  @media (min-width: 768px) {
    .modal {
      height: calc(100% - 110px);
    }
  }

  .modal.hidden {
    display: none !important;
  }

  .modal.active {
    display: flex;
  }

  .modal h1 {
    color: #ffff00;
    text-shadow: 5px 5px #c0392b;
    font-size: 32px;
    margin-bottom: 20px;
    line-height: 1.2;
  }

  .modal h1.danger {
    color: #e74c3c;
    text-shadow: 3px 3px #000;
  }

  .modal h1.win {
    color: #2ecc71;
    text-shadow: 3px 3px #000;
  }

  .modal p {
    font-size: 10px;
    margin: 5px 0;
  }

  .instructions {
    font-size: 12px;
    margin: 20px;
    line-height: 2;
    color: #ddd;
    background: rgba(0, 0, 0, 0.5);
    padding: 15px;
    border-radius: 8px;
    border: 2px solid #555;
  }

  .controls-title {
    color: #4cd137;
    font-size: 12px !important;
    margin-bottom: 10px !important;
  }

  .hint {
    color: #f1c40f;
    font-size: 10px !important;
  }

  .menu-btn {
    margin-top: 20px;
    padding: 15px 25px;
    font-family: 'Press Start 2P', cursive;
    background: #e74c3c;
    color: white;
    border: 4px solid #fff;
    cursor: pointer;
    text-transform: uppercase;
    font-size: 14px;
  }

  .menu-btn:active {
    transform: scale(0.95);
  }

  .blink {
    animation: blinker 1s linear infinite;
  }

  @keyframes blinker {
    50% {
      opacity: 0;
    }
  }

  /* Responsive - Ajustes para desktop */
  @media (min-width: 768px) {
    #gameboy-controls {
      height: 110px;
      padding: 8px 30px;
    }

    .dpad-btn {
      width: 65px;
      height: 65px;
    }

    .dpad-center {
      height: 65px;
    }

    .action-btn {
      width: 70px;
      height: 70px;
    }

    .control-label {
      font-size: 9px;
    }
  }
</style>

<script>
  ;(function () {
    const canvas = document.getElementById('pangCanvas') as HTMLCanvasElement | null
    if (!canvas) return
    const ctx = canvas.getContext('2d')
    if (!ctx) return

    // Resolución lógica del juego
    const GAME_WIDTH = 360
    const GAME_HEIGHT = 540

    canvas.width = GAME_WIDTH
    canvas.height = GAME_HEIGHT

    const livesDisplay = document.getElementById('lives-display') as HTMLElement
    const levelDisplay = document.getElementById('level-display') as HTMLElement
    const finalLevelDisplay = document.getElementById('final-level') as HTMLElement
    const startScreen = document.getElementById('start-screen') as HTMLElement
    const gameOverScreen = document.getElementById('game-over-screen') as HTMLElement
    const winScreen = document.getElementById('win-screen') as HTMLElement
    const startBtn = document.getElementById('start-btn') as HTMLElement
    const restartBtn = document.getElementById('restart-btn') as HTMLElement

    let gameState: 'MENU' | 'PLAYING' | 'GAMEOVER' | 'WIN' = 'MENU'
    let levelTransitioning = false
    let frames = 0
    let currentLevel = 1
    let shakeDuration = 0
    let hitFlash = 0
    let particles: Particle[] = []
    let bubbles: Bubble[] = []
    let lasers: Laser[] = []

    // Fixed timestep para física consistente en todos los dispositivos
    const FIXED_DT = 1 / 60 // 60 updates por segundo
    const MAX_FRAME_TIME = 0.25 // Máximo tiempo de frame para evitar espiral de muerte
    let lastFrameTime = 0
    let accumulator = 0

    // Pre-calcular valores para shake
    let shakeX = 0
    let shakeY = 0

    const TARGET_LEVELS = 3
    const BASE_GRAVITY = 600 // pixels per second squared
    const COLORS = {
      glasses: '#000000',
      laser: '#ff0055',
      laserCore: '#ffffff',
      ready: '#00ff00',
      charging: '#550000',
    }

    // Audio
    const AudioContext = window.AudioContext || (window as any).webkitAudioContext
    let audioCtx: AudioContext | null = null

    function initAudio() {
      if (!audioCtx) {
        audioCtx = new AudioContext()
      }
      if (audioCtx.state === 'suspended') {
        audioCtx.resume()
      }
    }

    const sfx = {
      start: () => {
        if (!audioCtx) return
        if (audioCtx.state === 'suspended') audioCtx.resume()
        const now = audioCtx.currentTime
        const osc = audioCtx.createOscillator()
        const gain = audioCtx.createGain()
        osc.type = 'square'
        osc.frequency.setValueAtTime(440, now)
        osc.frequency.setValueAtTime(554, now + 0.1)
        osc.frequency.setValueAtTime(659, now + 0.2)
        osc.frequency.setValueAtTime(880, now + 0.3)
        gain.gain.setValueAtTime(0.1, now)
        gain.gain.linearRampToValueAtTime(0, now + 0.6)
        osc.connect(gain)
        gain.connect(audioCtx.destination)
        osc.start()
        osc.stop(now + 0.6)
      },
      shoot: () => {
        if (!audioCtx) return
        if (audioCtx.state === 'suspended') audioCtx.resume()
        const osc = audioCtx.createOscillator()
        const gain = audioCtx.createGain()
        osc.type = 'square'
        osc.frequency.setValueAtTime(400, audioCtx.currentTime)
        osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1)
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime)
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1)
        osc.connect(gain)
        gain.connect(audioCtx.destination)
        osc.start()
        osc.stop(audioCtx.currentTime + 0.1)
      },
      pop: () => {
        if (!audioCtx) return
        if (audioCtx.state === 'suspended') audioCtx.resume()
        const osc = audioCtx.createOscillator()
        const gain = audioCtx.createGain()
        osc.type = 'triangle'
        osc.frequency.setValueAtTime(200, audioCtx.currentTime)
        osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.05)
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime)
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.05)
        osc.connect(gain)
        gain.connect(audioCtx.destination)
        osc.start()
        osc.stop(audioCtx.currentTime + 0.05)
      },
      hit: () => {
        if (!audioCtx) return
        if (audioCtx.state === 'suspended') audioCtx.resume()
        const now = audioCtx.currentTime
        const osc = audioCtx.createOscillator()
        const gain = audioCtx.createGain()
        osc.type = 'sawtooth'
        osc.frequency.setValueAtTime(150, now)
        osc.frequency.exponentialRampToValueAtTime(10, now + 0.4)
        gain.gain.setValueAtTime(0.3, now)
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4)
        osc.connect(gain)
        gain.connect(audioCtx.destination)
        osc.start()
        osc.stop(now + 0.5)
      },
      gameover: () => {
        if (!audioCtx) return
        if (audioCtx.state === 'suspended') audioCtx.resume()
        const now = audioCtx.currentTime
        const osc = audioCtx.createOscillator()
        const gain = audioCtx.createGain()
        osc.type = 'triangle'
        osc.frequency.setValueAtTime(300, now)
        osc.frequency.linearRampToValueAtTime(100, now + 1.5)
        const lfo = audioCtx.createOscillator()
        lfo.frequency.value = 5
        const lfoGain = audioCtx.createGain()
        lfoGain.gain.value = 10
        lfo.connect(lfoGain)
        lfoGain.connect(osc.frequency)
        lfo.start()
        gain.gain.setValueAtTime(0.2, now)
        gain.gain.linearRampToValueAtTime(0, now + 1.5)
        osc.connect(gain)
        gain.connect(audioCtx.destination)
        osc.start()
        osc.stop(now + 1.5)
        lfo.stop(now + 1.5)
      },
      win: () => {
        if (!audioCtx) return
        ;[440, 554, 659, 880].forEach((freq, i) => {
          setTimeout(() => {
            if (!audioCtx) return
            const osc = audioCtx.createOscillator()
            const gain = audioCtx.createGain()
            osc.type = 'square'
            osc.frequency.value = freq
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime)
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2)
            osc.connect(gain)
            gain.connect(audioCtx.destination)
            osc.start()
            osc.stop(audioCtx.currentTime + 0.2)
          }, i * 100)
        })
      },
    }

    class Player {
      width = 44
      height = 18
      x = GAME_WIDTH / 2 - 22
      y = GAME_HEIGHT - 40
      speed = 200 // pixels per second
      dx = 0
      lives = 3
      legFrame = 0
      canShoot = true
      laserActive = false
      invulnerable = false
      invulnerableTimer = 0
      visible = true

      update(dt: number) {
        this.x += this.dx * dt
        if (this.x < 0) this.x = 0
        if (this.x + this.width > GAME_WIDTH) this.x = GAME_WIDTH - this.width

        if (this.dx !== 0) {
          this.legFrame += 12 * dt
        } else {
          this.legFrame = 0
        }

        if (this.invulnerable) {
          this.invulnerableTimer -= dt
          // Toggle visibility cada ~4 frames (aprox 66ms)
          this.visible = (frames & 3) < 2
          if (this.invulnerableTimer <= 0) {
            this.invulnerable = false
            this.visible = true
          }
        }
      }

      draw() {
        if (!this.visible) return

        const x = this.x | 0 // Faster than Math.floor
        const y = this.y | 0
        const legHeight = 14
        const leftLegX = x + 8
        const rightLegX = x + this.width - 8
        const walkOffset = Math.sin(this.legFrame) * 5

        ctx!.strokeStyle = '#000'
        ctx!.lineWidth = 4

        ctx!.beginPath()
        ctx!.moveTo(leftLegX, y + 10)
        ctx!.lineTo(leftLegX - walkOffset, y + 10 + legHeight)
        ctx!.stroke()

        ctx!.beginPath()
        ctx!.moveTo(rightLegX, y + 10)
        ctx!.lineTo(rightLegX + walkOffset, y + 10 + legHeight)
        ctx!.stroke()

        ctx!.fillStyle = COLORS.glasses
        ctx!.fillRect(x, y, this.width, this.height)

        ctx!.fillStyle = '#222'
        ctx!.fillRect(x + 4, y + 2, 16, 14)
        ctx!.fillRect(x + 24, y + 2, 16, 14)

        ctx!.fillStyle = '#eee'
        ctx!.fillRect(x + 6, y + 4, 4, 4)
        ctx!.fillRect(x + 12, y + 10, 2, 2)
        ctx!.fillRect(x + 26, y + 4, 4, 4)
        ctx!.fillRect(x + 32, y + 10, 2, 2)

        // Indicador de disparo
        const bridgeX = x + 20
        if (this.canShoot && !this.laserActive) {
          ctx!.fillStyle = (frames & 14) < 7 ? COLORS.ready : '#ccffcc'
        } else {
          ctx!.fillStyle = COLORS.charging
        }
        ctx!.fillRect(bridgeX, y + 6, 4, 6)
      }

      shoot() {
        if (this.canShoot && !this.laserActive) {
          sfx.shoot()
          lasers.push(new Laser(this.x + this.width / 2, this.y))
          this.canShoot = false
          this.laserActive = true
        }
      }
    }

    class Laser {
      x: number
      y: number
      height = 0
      growSpeed = 1800 // pixels per second
      lifeTime = 1 // seconds
      active = true
      fullyExtended = false

      constructor(x: number, startY: number) {
        this.x = x | 0
        this.y = startY | 0
      }

      update(dt: number) {
        if (!this.fullyExtended) {
          this.height += this.growSpeed * dt
          if (this.y - this.height <= 0) {
            this.height = this.y
            this.fullyExtended = true
          }
        }

        this.lifeTime -= dt
        if (this.lifeTime <= 0) {
          this.active = false
          player.laserActive = false
          player.canShoot = true
        }
      }

      draw() {
        const drawY = (this.y - this.height) | 0
        const h = this.height | 0

        // Alternar color para efecto de parpadeo
        ctx!.fillStyle = frames & 1 ? COLORS.laser : '#ff99aa'
        ctx!.fillRect(this.x - 2, drawY, 4, h)

        // Glow lateral
        ctx!.fillStyle = 'rgba(255, 0, 100, 0.5)'
        ctx!.fillRect(this.x - 4, drawY, 2, h)
        ctx!.fillRect(this.x + 2, drawY, 2, h)
      }
    }

    class Bubble {
      x: number
      y: number
      radius: number
      dx: number
      dy: number
      color: string
      markedForDeletion = false
      bounceForce: number

      constructor(x: number, y: number, radius: number, dx: number, dy: number, color: string) {
        this.x = x
        this.y = y
        this.radius = radius
        this.dx = dx * 50 // pixels per second
        this.dy = dy * 60 // pixels per second
        this.color = color
        // Pre-calcular fuerza de rebote basada en tamaño
        this.bounceForce = radius < 15 ? -360 : radius > 30 ? -570 : -450
      }

      update(dt: number) {
        this.dy += BASE_GRAVITY * dt
        this.x += this.dx * dt
        this.y += this.dy * dt

        // Colisión con paredes
        if (this.x - this.radius < 0) {
          this.x = this.radius
          this.dx = -this.dx
        } else if (this.x + this.radius > GAME_WIDTH) {
          this.x = GAME_WIDTH - this.radius
          this.dx = -this.dx
        }

        // Colisión con suelo
        if (this.y + this.radius > GAME_HEIGHT) {
          this.y = GAME_HEIGHT - this.radius
          this.dy = this.bounceForce
        }
      }

      draw() {
        const r = this.radius | 0
        const x = this.x | 0
        const y = this.y | 0
        const offset = (r * 0.4) | 0
        const doubleR = r << 1

        ctx!.fillStyle = this.color
        ctx!.fillRect(x - r + offset, y - r, (r - offset) << 1, doubleR)
        ctx!.fillRect(x - r, y - r + offset, doubleR, (r - offset) << 1)
        ctx!.fillRect(x - r + 2, y - r + 2, doubleR - 4, doubleR - 4)

        // Brillo
        ctx!.fillStyle = '#fff'
        const shineSize = r > 6 ? (r / 3) | 0 : 2
        ctx!.fillRect(x - (r >> 1), y - (r >> 1), shineSize, shineSize)

        // Borde
        ctx!.strokeStyle = 'rgba(0,0,0,0.3)'
        ctx!.lineWidth = 2
        ctx!.strokeRect(x - r + offset, y - r, (r - offset) << 1, doubleR)
      }
    }

    class Particle {
      x: number
      y: number
      size: number
      dx: number
      dy: number
      color: string
      life: number

      constructor(x: number, y: number, color: string) {
        this.x = x
        this.y = y
        this.size = Math.random() * 6 + 2
        this.dx = (Math.random() - 0.5) * 480
        this.dy = (Math.random() - 0.5) * 480
        this.color = color
        this.life = 0.33
      }

      update(dt: number) {
        this.x += this.dx * dt
        this.y += this.dy * dt
        this.life -= dt
        this.size -= 3 * dt
      }

      draw() {
        if (this.size > 0) {
          ctx!.fillStyle = this.color
          ctx!.fillRect(this.x | 0, this.y | 0, this.size | 0, this.size | 0)
        }
      }
    }

    let player = new Player()

    function initLevel(level: number) {
      bubbles = []
      lasers = []

      const bubbleColors = ['#e74c3c', '#3498db', '#f1c40f', '#2ecc71', '#9b59b6']

      if (level === 1) {
        bubbles.push(new Bubble(GAME_WIDTH / 2, 100, 32, 1.5, 0, bubbleColors[0]))
        bubbles.push(new Bubble(50, 150, 20, -1.5, 0, bubbleColors[1]))
      } else if (level === 2) {
        bubbles.push(new Bubble(GAME_WIDTH / 2, 80, 36, 1.8, 0, bubbleColors[2]))
        bubbles.push(new Bubble(80, 120, 24, -1.5, 0, bubbleColors[0]))
        bubbles.push(new Bubble(GAME_WIDTH - 80, 120, 24, 1.5, 0, bubbleColors[1]))
      } else if (level === 3) {
        bubbles.push(new Bubble(GAME_WIDTH / 2, 60, 40, 2, 0, bubbleColors[3]))
        bubbles.push(new Bubble(60, 100, 28, -2, 0, bubbleColors[4]))
        bubbles.push(new Bubble(GAME_WIDTH - 60, 100, 28, 1.8, 0, bubbleColors[0]))
        bubbles.push(new Bubble(GAME_WIDTH / 2, 150, 20, -1.5, 0, bubbleColors[1]))
      }

      levelDisplay.innerText = String(level)
    }

    function spawnBubbles(x: number, y: number, radius: number, color: string) {
      const newRadius = radius / 2
      if (newRadius < 8) return
      bubbles.push(new Bubble(x, y - 5, newRadius, -2.5, -4, color))
      bubbles.push(new Bubble(x, y - 5, newRadius, 2.5, -4, color))
    }

    function fixedUpdate() {
      if (gameState !== 'PLAYING') return

      // Decrementar timers con timestep fijo
      if (shakeDuration > 0) {
        shakeDuration -= FIXED_DT
        shakeX = (Math.random() - 0.5) * 12
        shakeY = (Math.random() - 0.5) * 12
      } else {
        shakeX = 0
        shakeY = 0
      }
      if (hitFlash > 0) hitFlash -= FIXED_DT

      player.update(FIXED_DT)

      // Update lasers
      for (let i = lasers.length - 1; i >= 0; i--) {
        lasers[i].update(FIXED_DT)
        if (!lasers[i].active) lasers.splice(i, 1)
      }

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update(FIXED_DT)
        if (particles[i].life <= 0) particles.splice(i, 1)
      }

      // Update bubbles y colisiones
      let hasBubblesToRemove = false
      const playerCenterX = player.x + player.width / 2
      const playerCenterY = player.y + player.height / 2
      const playerHalfW = player.width / 2
      const playerHalfH = player.height / 2

      for (let i = bubbles.length - 1; i >= 0; i--) {
        const b = bubbles[i]
        b.update(FIXED_DT)

        // Colisión con lasers
        for (let j = 0; j < lasers.length; j++) {
          const laser = lasers[j]
          if (laser.active) {
            const laserLeft = laser.x - 4
            const laserRight = laser.x + 4
            const laserTop = laser.y - laser.height

            if (
              b.x + b.radius > laserLeft &&
              b.x - b.radius < laserRight &&
              b.y + b.radius > laserTop &&
              b.y - b.radius < laser.y
            ) {
              b.markedForDeletion = true
              hasBubblesToRemove = true
              sfx.pop()

              // Crear partículas (limitadas)
              const particleCount = Math.min(6, 20 - particles.length)
              for (let k = 0; k < particleCount; k++) {
                particles.push(new Particle(b.x, b.y, b.color))
              }

              spawnBubbles(b.x, b.y, b.radius, b.color)
              break
            }
          }
        }

        // Colisión con jugador
        if (!player.invulnerable && !b.markedForDeletion) {
          const distX = Math.abs(b.x - playerCenterX)
          const distY = Math.abs(b.y - playerCenterY)

          if (distX < playerHalfW + b.radius - 6 && distY < playerHalfH + b.radius - 6) {
            handleDeath(b)
            hasBubblesToRemove = true
          }
        }
      }

      // Solo filtrar si hay burbujas para eliminar
      if (hasBubblesToRemove) {
        bubbles = bubbles.filter((b) => !b.markedForDeletion)
      }

      // Check level completion
      if (bubbles.length === 0 && !levelTransitioning) {
        levelTransitioning = true

        if (currentLevel >= TARGET_LEVELS) {
          gameState = 'WIN'
          sfx.win()
          winScreen.classList.remove('hidden')

          setTimeout(() => {
            window.dispatchEvent(new CustomEvent('game-completed'))
          }, 1500)
        } else {
          currentLevel++
          setTimeout(() => {
            initLevel(currentLevel)
            levelTransitioning = false
          }, 1000)
        }
      }
    }

    function handleDeath(offendingBubble: Bubble | null) {
      if (player.invulnerable) return

      sfx.hit()
      player.lives--

      livesDisplay.innerHTML = '❤'.repeat(Math.max(0, player.lives))

      shakeDuration = 0.33
      hitFlash = 0.17

      for (let i = 0; i < 20; i++) {
        particles.push(new Particle(player.x + 20, player.y, '#fff'))
      }

      if (offendingBubble) {
        offendingBubble.markedForDeletion = true
        for (let k = 0; k < 8; k++) {
          particles.push(new Particle(offendingBubble.x, offendingBubble.y, offendingBubble.color))
        }
        spawnBubbles(
          offendingBubble.x,
          offendingBubble.y,
          offendingBubble.radius,
          offendingBubble.color
        )
      }

      if (player.lives > 0) {
        player.invulnerable = true
        player.invulnerableTimer = 3 // seconds
        player.x = GAME_WIDTH / 2 - player.width / 2
      } else {
        gameState = 'GAMEOVER'
        sfx.gameover()
        finalLevelDisplay.innerText = String(currentLevel)
        gameOverScreen.classList.remove('hidden')
      }
    }

    function draw() {
      // Fondo
      ctx!.fillStyle = '#1a1a2e'
      ctx!.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT)

      // Aplicar shake si está activo
      if (shakeDuration > 0) {
        ctx!.save()
        ctx!.translate(shakeX, shakeY)
      }

      // Buildings (fondo estático)
      ctx!.fillStyle = '#111'
      ctx!.fillRect(20, GAME_HEIGHT - 120, 40, 120)
      ctx!.fillRect(65, GAME_HEIGHT - 180, 50, 180)
      ctx!.fillRect(120, GAME_HEIGHT - 80, 60, 80)
      ctx!.fillRect(190, GAME_HEIGHT - 140, 45, 140)
      ctx!.fillRect(250, GAME_HEIGHT - 100, 50, 100)
      ctx!.fillRect(305, GAME_HEIGHT - 160, 55, 160)

      // Windows
      ctx!.fillStyle = '#333'
      ctx!.fillRect(75, GAME_HEIGHT - 160, 4, 4)
      ctx!.fillRect(85, GAME_HEIGHT - 160, 4, 4)
      ctx!.fillRect(75, GAME_HEIGHT - 140, 4, 4)
      ctx!.fillRect(85, GAME_HEIGHT - 140, 4, 4)

      // Floor
      ctx!.fillStyle = '#555'
      ctx!.fillRect(0, GAME_HEIGHT - 10, GAME_WIDTH, 10)
      ctx!.fillStyle = '#333'
      for (let i = 0; i < GAME_WIDTH; i += 20) ctx!.fillRect(i, GAME_HEIGHT - 10, 2, 10)

      // Dibujar entidades
      player.draw()

      for (let i = 0; i < lasers.length; i++) {
        lasers[i].draw()
      }
      for (let i = 0; i < bubbles.length; i++) {
        bubbles[i].draw()
      }
      for (let i = 0; i < particles.length; i++) {
        particles[i].draw()
      }

      if (shakeDuration > 0) {
        ctx!.restore()
      }

      // Hit flash overlay
      if (hitFlash > 0) {
        ctx!.fillStyle = `rgba(255, 0, 0, ${hitFlash / 0.33})`
        ctx!.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT)
      }
    }

    function loop(timestamp: number) {
      // Calcular tiempo transcurrido
      if (lastFrameTime === 0) {
        lastFrameTime = timestamp
      }

      let frameTime = (timestamp - lastFrameTime) / 1000
      lastFrameTime = timestamp

      // Limitar frameTime para evitar espiral de muerte
      if (frameTime > MAX_FRAME_TIME) {
        frameTime = MAX_FRAME_TIME
      }

      // Procesar input una vez por frame
      handleInput()

      // Acumular tiempo y ejecutar updates con timestep fijo
      accumulator += frameTime

      while (accumulator >= FIXED_DT) {
        fixedUpdate()
        accumulator -= FIXED_DT
        frames++
      }

      // Render una vez por frame (a la velocidad del monitor)
      draw()

      requestAnimationFrame(loop)
    }

    // Input
    const keys: Record<string, boolean> = {}
    const btnLeft = document.getElementById('btn-left')
    const btnRight = document.getElementById('btn-right')
    const btnShoot = document.getElementById('btn-shoot')

    let touchLeft = false
    let touchRight = false

    // Update visual button state based on keyboard
    function updateButtonVisuals() {
      const leftPressed = keys['ArrowLeft'] || keys['KeyA']
      const rightPressed = keys['ArrowRight'] || keys['KeyD']
      const shootPressed = keys['Space']

      if (btnLeft) {
        if (leftPressed) {
          btnLeft.classList.add('pressed')
        } else if (!touchLeft) {
          btnLeft.classList.remove('pressed')
        }
      }

      if (btnRight) {
        if (rightPressed) {
          btnRight.classList.add('pressed')
        } else if (!touchRight) {
          btnRight.classList.remove('pressed')
        }
      }

      if (btnShoot) {
        if (shootPressed) {
          btnShoot.classList.add('pressed')
        } else {
          btnShoot.classList.remove('pressed')
        }
      }
    }

    window.addEventListener('keydown', (e) => {
      keys[e.code] = true
      updateButtonVisuals()
      if (e.code === 'Space') {
        e.preventDefault()
        if (gameState === 'PLAYING') player.shoot()
        initAudio()
      }
    })

    window.addEventListener('keyup', (e) => {
      keys[e.code] = false
      updateButtonVisuals()
    })

    function addButtonLogic(
      elem: HTMLElement | null,
      actionDown: () => void,
      actionUp: () => void
    ) {
      if (!elem) return
      const start = (e: Event) => {
        e.preventDefault()
        elem.classList.add('pressed')
        actionDown()
      }
      const end = (e: Event) => {
        e.preventDefault()
        elem.classList.remove('pressed')
        actionUp()
      }

      elem.addEventListener('mousedown', start)
      elem.addEventListener('touchstart', start)
      elem.addEventListener('mouseup', end)
      elem.addEventListener('touchend', end)
      elem.addEventListener('mouseleave', end)
    }

    addButtonLogic(
      btnLeft,
      () => (touchLeft = true),
      () => (touchLeft = false)
    )
    addButtonLogic(
      btnRight,
      () => (touchRight = true),
      () => (touchRight = false)
    )
    addButtonLogic(
      btnShoot,
      () => {
        initAudio()
        if (gameState === 'PLAYING') player.shoot()
      },
      () => {}
    )

    // Allow clicking on canvas area to shoot as well
    canvas.addEventListener('pointerdown', (e) => {
      e.preventDefault()
      initAudio()
      if (gameState === 'PLAYING') {
        player.shoot()
        btnShoot?.classList.add('pressed')
        setTimeout(() => btnShoot?.classList.remove('pressed'), 100)
      }
    })

    function handleInput() {
      if (gameState !== 'PLAYING') return

      player.dx = 0
      if (keys['ArrowLeft'] || keys['KeyA'] || touchLeft) player.dx = -player.speed
      if (keys['ArrowRight'] || keys['KeyD'] || touchRight) player.dx = player.speed
    }

    function startGame() {
      initAudio()
      sfx.start()
      startScreen.classList.add('hidden')
      gameState = 'PLAYING'
      currentLevel = 1
      player = new Player()
      particles = []
      livesDisplay.innerHTML = '❤❤❤'
      levelTransitioning = false
      lastFrameTime = 0
      accumulator = 0
      initLevel(currentLevel)
    }

    function restartGame() {
      gameOverScreen.classList.add('hidden')
      sfx.start()
      currentLevel = 1
      player = new Player()
      particles = []
      livesDisplay.innerHTML = '❤❤❤'
      levelTransitioning = false
      gameState = 'PLAYING'
      lastFrameTime = 0
      accumulator = 0
      initLevel(currentLevel)
    }

    startBtn?.addEventListener('click', startGame)
    restartBtn?.addEventListener('click', restartGame)

    // Start the loop
    requestAnimationFrame(loop)
  })()
</script>
