---
import GameLayout from '@/components/games/GameLayout.astro'

export interface Props {
  day: number
  gameData?: {
    targetScore?: number
    prize?: string
    videoUrl?: string
  }
}

const { day, gameData } = Astro.props

const GAME_DATA = {
  day: day,
  targetScore: gameData?.targetScore || 1,
  prize: gameData?.prize || 'Premio del día',
  videoUrl: gameData?.videoUrl,
}
---

<GameLayout prize={GAME_DATA.prize} videoUrl={GAME_DATA.videoUrl}>
  <canvas id="racerCanvas" slot="game"></canvas>
</GameLayout>

<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

  #racerCanvas {
    display: block;
    width: 100%;
    height: 100%;
    image-rendering: pixelated;
    outline: none;
    -webkit-tap-highlight-color: transparent;
  }
</style>

<script>
  import { actions } from 'astro:actions'
  import { showAchievement } from '@/utils/show-achievement'
  ;(function () {
    /**
     * CONFIGURACIÓN DEL JUEGO
     */
    const TARGET_SCORE = 7
    const LANE_COUNT = 3
    const INITIAL_SPEED = 3
    const SPEED_INCREMENT = 0.0005
    const INTERNAL_WIDTH = 360
    const INTERNAL_HEIGHT = 640

    /**
     * SPRITES (DISEÑOS PIXEL ART)
     */
    const SPRITES = {
      car: [
        [0, 3, 1, 1, 1, 3, 0],
        [0, 3, 1, 1, 1, 3, 0],
        [0, 1, 1, 2, 1, 1, 0],
        [0, 1, 2, 2, 2, 1, 0],
        [0, 1, 1, 1, 1, 1, 0],
        [0, 1, 1, 1, 1, 1, 0],
        [0, 1, 1, 3, 1, 1, 0],
        [0, 3, 1, 1, 1, 3, 0],
        [0, 3, 1, 1, 1, 3, 0],
        [0, 0, 1, 1, 1, 0, 0],
      ],
      coin: [
        [0, 0, 1, 1, 1, 0, 0],
        [0, 1, 2, 2, 2, 1, 0],
        [1, 2, 3, 3, 2, 2, 1],
        [1, 2, 3, 3, 2, 2, 1],
        [1, 2, 2, 2, 2, 2, 1],
        [0, 1, 2, 2, 2, 1, 0],
        [0, 0, 1, 1, 1, 0, 0],
      ],
      arrowLeft: [
        [0, 0, 0, 0, 1, 0, 0, 0],
        [0, 0, 0, 1, 1, 0, 0, 0],
        [0, 0, 1, 1, 1, 0, 0, 0],
        [0, 1, 1, 1, 1, 1, 1, 1],
        [0, 0, 1, 1, 1, 0, 0, 0],
        [0, 0, 0, 1, 1, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0],
      ],
      arrowRight: [
        [0, 0, 0, 1, 0, 0, 0, 0],
        [0, 0, 0, 1, 1, 0, 0, 0],
        [0, 0, 0, 1, 1, 1, 0, 0],
        [1, 1, 1, 1, 1, 1, 1, 0],
        [0, 0, 0, 1, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0, 0],
        [0, 0, 0, 1, 0, 0, 0, 0],
      ],
    }

    const PALETTES = {
      player: { 1: '#2ecc71', 2: '#27ae60', 3: '#2c3e50' },
      enemy1: { 1: '#e74c3c', 2: '#c0392b', 3: '#2c3e50' },
      enemy2: { 1: '#3498db', 2: '#2980b9', 3: '#2c3e50' },
      coin: { 1: '#f39c12', 2: '#f1c40f', 3: '#ffeaa7' },
      ui: { 1: '#333333', 2: '#cccccc' },
    }

    /**
     * SISTEMA DE SONIDO (Web Audio API)
     */
    const audioCtx = new (
      window.AudioContext || (window as any).webkitAudioContext
    )() as AudioContext

    // Música de fondo
    const bgMusic = new Audio('https://videos.bigibai.com/music/racer-music.mp3')
    bgMusic.loop = true
    bgMusic.volume = 0.3

    function playSound(type: string) {
      if (audioCtx.state === 'suspended') {
        audioCtx.resume()
      }
      const osc = audioCtx.createOscillator()
      const gainNode = audioCtx.createGain()

      osc.connect(gainNode)
      gainNode.connect(audioCtx.destination)
      const now = audioCtx.currentTime

      if (type === 'coin') {
        osc.type = 'sine'
        osc.frequency.setValueAtTime(1200, now)
        osc.frequency.exponentialRampToValueAtTime(1800, now + 0.1)

        gainNode.gain.setValueAtTime(0.3, now)
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15)

        osc.start(now)
        osc.stop(now + 0.15)

        const osc2 = audioCtx.createOscillator()
        const gain2 = audioCtx.createGain()
        osc2.connect(gain2)
        gain2.connect(audioCtx.destination)
        osc2.type = 'sine'
        osc2.frequency.setValueAtTime(1800, now + 0.05)
        gain2.gain.setValueAtTime(0.3, now + 0.05)
        gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.2)
        osc2.start(now + 0.05)
        osc2.stop(now + 0.2)
      } else if (type === 'move') {
        osc.type = 'triangle'
        osc.frequency.setValueAtTime(300, now)
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.1)

        gainNode.gain.setValueAtTime(0.1, now)
        gainNode.gain.linearRampToValueAtTime(0.01, now + 0.1)

        osc.start(now)
        osc.stop(now + 0.1)
      } else if (type === 'crash') {
        osc.type = 'sawtooth'
        osc.frequency.setValueAtTime(150, now)
        osc.frequency.exponentialRampToValueAtTime(20, now + 0.5)

        const lfo = audioCtx.createOscillator()
        lfo.frequency.value = 50
        const lfoGain = audioCtx.createGain()
        lfoGain.gain.value = 500
        lfo.connect(lfoGain)
        lfoGain.connect(osc.frequency)
        lfo.start(now)

        gainNode.gain.setValueAtTime(0.4, now)
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5)

        osc.start(now)
        osc.stop(now + 0.5)
        lfo.stop(now + 0.5)
      }
    }

    /**
     * MOTOR DEL JUEGO
     */
    const canvas = document.getElementById('racerCanvas') as HTMLCanvasElement
    if (!canvas) return

    const ctx = canvas.getContext('2d')
    if (!ctx) return

    // Estado del juego
    let state = {
      status: 'start',
      score: 0,
      speed: INITIAL_SPEED,
      laneOffset: 0,
      laneWidth: 0,
      frames: 0,
      lastTime: 0,
      accumulator: 0,
    }

    // Constantes de tiempo (60 FPS target)
    const TARGET_FPS = 60
    const FRAME_TIME = 1000 / TARGET_FPS // ~16.67ms

    // Entidades
    let player = { lane: 1, y: 0, animY: 0 }
    let enemies: { lane: number; y: number; type: string }[] = []
    let coins: { lane: number; y: number }[] = []

    // Inputs visuales
    let buttons = {
      left: { x: 40, y: 550, w: 80, h: 80, pressed: false },
      right: { x: 240, y: 550, w: 80, h: 80, pressed: false },
      restart: { x: 100, y: 400, w: 160, h: 50 },
    }

    /**
     * INICIALIZACIÓN
     */
    function initRacerGame() {
      canvas.width = INTERNAL_WIDTH
      canvas.height = INTERNAL_HEIGHT

      state.laneWidth = INTERNAL_WIDTH / LANE_COUNT
      player.y = INTERNAL_HEIGHT - 200

      window.addEventListener('keydown', handleKey)
      window.addEventListener('keyup', handleKeyUp)

      canvas.addEventListener('mousedown', handleInputStart)
      canvas.addEventListener('mouseup', handleInputEnd)
      canvas.addEventListener(
        'touchstart',
        (e) => {
          e.preventDefault()
          handleInputStart(e.touches[0])
        },
        { passive: false }
      )
      canvas.addEventListener('touchend', (e) => {
        e.preventDefault()
        handleInputEnd()
      })

      document.fonts.ready.then(function () {
        state.lastTime = performance.now()
        requestAnimationFrame(loop)
      })
    }

    function resetGame() {
      state.status = 'playing'
      state.score = 0
      state.speed = INITIAL_SPEED
      state.lastTime = performance.now()
      state.accumulator = 0
      player.lane = 1
      enemies = []
      coins = []

      // Iniciar música de fondo
      bgMusic.currentTime = 0
      bgMusic.play()
    }

    /**
     * INPUT HANDLING
     */
    function handleKey(e: KeyboardEvent) {
      if (state.status !== 'playing') return
      if (e.key === 'ArrowLeft') {
        movePlayer(-1)
        buttons.left.pressed = true
      }
      if (e.key === 'ArrowRight') {
        movePlayer(1)
        buttons.right.pressed = true
      }
    }

    function handleKeyUp(e: KeyboardEvent) {
      buttons.left.pressed = false
      buttons.right.pressed = false
    }

    function getCanvasCoords(event: MouseEvent) {
      const rect = canvas.getBoundingClientRect()
      const scaleX = canvas.width / rect.width
      const scaleY = canvas.height / rect.height
      return {
        x: (event.clientX - rect.left) * scaleX,
        y: (event.clientY - rect.top) * scaleY,
      }
    }

    function handleInputStart(e: MouseEvent | TouchEvent) {
      // ACTIVAR AUDIO EN PRIMER CLICK
      if (audioCtx.state === 'suspended') {
        audioCtx.resume()
      }
      const pos = getCanvasCoords(e)
      if (state.status === 'playing') {
        if (hitTest(pos, buttons.left)) {
          movePlayer(-1)
          buttons.left.pressed = true
        }
        if (hitTest(pos, buttons.right)) {
          movePlayer(1)
          buttons.right.pressed = true
        }
      } else if (state.status === 'start' || state.status === 'gameover') {
        resetGame()
      }
    }

    function handleInputEnd() {
      buttons.left.pressed = false
      buttons.right.pressed = false
    }

    function hitTest(
      pos: { x: number; y: number },
      btn: { x: number; y: number; w: number; h: number }
    ) {
      return pos.x >= btn.x && pos.x <= btn.x + btn.w && pos.y >= btn.y && pos.y <= btn.y + btn.h
    }

    function movePlayer(dir: number) {
      const newLane = player.lane + dir
      if (newLane >= 0 && newLane < LANE_COUNT) {
        player.lane = newLane
        playSound('move')
      }
    }

    /**
     * UPDATE LOGIC (Fixed timestep)
     */
    function update() {
      if (state.status !== 'playing') return

      state.frames++
      state.speed += SPEED_INCREMENT
      state.laneOffset = (state.laneOffset + state.speed * 4) % 80

      const spawnRateEnemy = Math.max(30, Math.floor(600 / state.speed))
      const spawnRateCoin = Math.max(20, Math.floor(400 / state.speed))

      if (state.frames % spawnRateEnemy === 0) spawnEnemy()
      if (state.frames % spawnRateCoin === 0) spawnCoin()

      updateEntities(enemies, state.speed * 4)
      updateEntities(coins, state.speed * 4)
      checkCollisions()

      if (state.score >= TARGET_SCORE) {
        state.status = 'win'
        bgMusic.pause()
        setTimeout(() => {
          // Emitir evento de victoria para que el GameLayout maneje el video
          window.dispatchEvent(new CustomEvent('game-completed'))

          // Otorgar logro específico del juego
          actions
            .grantGameAchievement({ achievementId: 'a-todo-gas' })
            .then((result) => {
              if (result.data?.achievement) {
                showAchievement('achievement-notification', {
                  title: result.data.achievement.title,
                  description: result.data.achievement.description,
                  icon: result.data.achievement.image,
                })
              }
            })
            .catch((error) => {
              console.error('Error granting achievement:', error)
            })
        }, 1500)
      }
    }

    function spawnEnemy() {
      let lane = Math.floor(Math.random() * LANE_COUNT)
      enemies.push({
        lane: lane,
        y: -100,
        type: Math.random() > 0.5 ? 'enemy1' : 'enemy2',
      })
    }

    function spawnCoin() {
      let lane = Math.floor(Math.random() * LANE_COUNT)
      if (!enemies.some((e) => e.lane === lane && e.y < 50)) {
        coins.push({ lane: lane, y: -100 })
      }
    }

    function updateEntities(arr: { lane: number; y: number }[], speed: number) {
      for (let i = arr.length - 1; i >= 0; i--) {
        arr[i].y += speed
        if (arr[i].y > INTERNAL_HEIGHT) arr.splice(i, 1)
      }
    }

    function checkCollisions() {
      const pY = player.y
      const pH = 70

      // Enemies
      enemies.forEach((e) => {
        if (e.lane === player.lane && e.y + 70 > pY + 10 && e.y < pY + pH - 10) {
          playSound('crash')
          state.status = 'gameover'
          bgMusic.pause()
        }
      })

      // Coins
      for (let i = coins.length - 1; i >= 0; i--) {
        let c = coins[i]
        if (c.lane === player.lane && c.y + 40 > pY && c.y < pY + pH) {
          state.score++
          playSound('coin')
          coins.splice(i, 1)
        }
      }
    }

    /**
     * DRAW LOGIC
     */
    function draw() {
      if (!ctx) return
      // Fondo
      ctx.fillStyle = '#333'
      ctx.fillRect(0, 0, INTERNAL_WIDTH, INTERNAL_HEIGHT)

      drawRoad()

      // Jugador
      const pX = player.lane * state.laneWidth + state.laneWidth / 2 - 25
      drawSprite(ctx, SPRITES.car, pX, player.y, 7, PALETTES.player)

      // Enemigos
      enemies.forEach((e) => {
        const x = e.lane * state.laneWidth + state.laneWidth / 2 - 25
        drawSprite(ctx, SPRITES.car, x, e.y, 7, PALETTES[e.type as keyof typeof PALETTES])
      })

      // Monedas
      coins.forEach((c) => {
        const x = c.lane * state.laneWidth + state.laneWidth / 2 - 15
        const bob = Math.sin(state.frames * 0.1) * 5
        drawSprite(ctx, SPRITES.coin, x, c.y + bob, 5, PALETTES.coin)
      })

      drawUI()
    }

    function drawRoad() {
      if (!ctx) return

      ctx.fillStyle = '#222'
      ctx.fillRect(20, 0, INTERNAL_WIDTH - 40, INTERNAL_HEIGHT)

      ctx.fillStyle = '#27ae60'
      ctx.fillRect(0, 0, 20, INTERNAL_HEIGHT)
      ctx.fillRect(INTERNAL_WIDTH - 20, 0, 20, INTERNAL_HEIGHT)

      ctx.fillStyle = '#fff'
      const dashH = 40
      const gapH = 40
      const totalH = dashH + gapH

      for (let i = -totalH; i < INTERNAL_HEIGHT; i += totalH) {
        let y = i + state.laneOffset
        ctx.fillRect(state.laneWidth - 2, y, 4, dashH)
        ctx.fillRect(state.laneWidth * 2 - 2, y, 4, dashH)
      }
    }

    function drawUI() {
      if (!ctx) return

      ctx.fillStyle = '#fff'
      ctx.font = '20px "Press Start 2P"'
      ctx.textAlign = 'center'

      ctx.fillStyle = '#000'
      ctx.fillText(`${state.score}/${TARGET_SCORE}`, INTERNAL_WIDTH / 2 + 2, 52)
      ctx.fillStyle = '#fff'
      ctx.fillText(`${state.score}/${TARGET_SCORE}`, INTERNAL_WIDTH / 2, 50)

      if (state.status === 'playing') {
        drawButton(buttons.left, SPRITES.arrowLeft)
        drawButton(buttons.right, SPRITES.arrowRight)
      }

      if (state.status === 'start') {
        drawOverlay('ADVENT RACER', 'CLICK PARA JUGAR', true)
      } else if (state.status === 'gameover') {
        drawOverlay('CHOQUE', 'REINTENTAR')
      } else if (state.status === 'win') {
        drawOverlay('GANASTE', 'DESBLOQUEANDO...')
      }
    }

    function drawButton(
      btn: { x: number; y: number; w: number; h: number; pressed: boolean },
      sprite: number[][]
    ) {
      if (!ctx) return

      ctx.fillStyle = btn.pressed ? '#bdc3c7' : '#ecf0f1'

      if (!btn.pressed) {
        ctx.fillRect(btn.x, btn.y, btn.w, btn.h)
        ctx.fillStyle = '#95a5a6'
        ctx.fillRect(btn.x, btn.y + btn.h, btn.w, 8)
      } else {
        ctx.fillRect(btn.x, btn.y + 4, btn.w, btn.h)
      }

      const iconScale = 5
      const iconW = sprite[0].length * iconScale
      const iconH = sprite.length * iconScale
      const iconX = btn.x + (btn.w - iconW) / 2
      const iconY = btn.y + (btn.h - iconH) / 2 + (btn.pressed ? 4 : 0)

      drawSprite(ctx, sprite, iconX, iconY, iconScale, PALETTES.ui)
    }

    function drawOverlay(title: string, subtitle: string, showInstructions = false) {
      if (!ctx) return

      ctx.fillStyle = 'rgba(0,0,0,0.85)'
      ctx.fillRect(0, 0, INTERNAL_WIDTH, INTERNAL_HEIGHT)

      ctx.textAlign = 'center'
      ctx.font = '30px "Press Start 2P"'

      // Dividir el título en dos líneas si contiene espacio
      const titleParts = title.split(' ')
      if (titleParts.length > 1) {
        // Sombra línea 1
        ctx.fillStyle = '#c0392b'
        ctx.fillText(titleParts[0], INTERNAL_WIDTH / 2 + 4, INTERNAL_HEIGHT / 2 - 40 + 4)
        // Título línea 1
        ctx.fillStyle = '#f1c40f'
        ctx.fillText(titleParts[0], INTERNAL_WIDTH / 2, INTERNAL_HEIGHT / 2 - 40)

        // Sombra línea 2
        ctx.fillStyle = '#c0392b'
        ctx.fillText(titleParts.slice(1).join(' '), INTERNAL_WIDTH / 2 + 4, INTERNAL_HEIGHT / 2 + 4)
        // Título línea 2
        ctx.fillStyle = '#f1c40f'
        ctx.fillText(titleParts.slice(1).join(' '), INTERNAL_WIDTH / 2, INTERNAL_HEIGHT / 2)
      } else {
        // Si no hay espacio, mostrar en una línea
        ctx.fillStyle = '#c0392b'
        ctx.fillText(title, INTERNAL_WIDTH / 2 + 4, INTERNAL_HEIGHT / 2 - 20 + 4)
        ctx.fillStyle = '#f1c40f'
        ctx.fillText(title, INTERNAL_WIDTH / 2, INTERNAL_HEIGHT / 2 - 20)
      }

      if (Math.floor(Date.now() / 500) % 2 === 0) {
        ctx.fillStyle = '#fff'
        ctx.font = '16px "Press Start 2P"'
        ctx.fillText(subtitle, INTERNAL_WIDTH / 2, INTERNAL_HEIGHT / 2 + 30)
      }

      // Mostrar instrucciones en pantalla de inicio
      if (showInstructions) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'
        ctx.font = '8px "Press Start 2P"'
        ctx.textAlign = 'center'
        ctx.fillText('CLIC EN FLECHAS O USA LAS TECLAS', INTERNAL_WIDTH / 2, INTERNAL_HEIGHT - 20)
        ctx.fillText(`RECOGE ${TARGET_SCORE} MONEDAS `, INTERNAL_WIDTH / 2, INTERNAL_HEIGHT - 8)
      }
    }

    function drawSprite(
      context: CanvasRenderingContext2D,
      matrix: number[][],
      x: number,
      y: number,
      size: number,
      palette: Record<number, string>
    ) {
      for (let r = 0; r < matrix.length; r++) {
        for (let c = 0; c < matrix[r].length; c++) {
          const pixelVal = matrix[r][c]
          if (pixelVal !== 0) {
            context.fillStyle = palette[pixelVal] || '#000'
            context.fillRect(x + c * size, y + r * size, size, size)
          }
        }
      }
    }

    function loop(currentTime: number) {
      // Calcular delta time
      const deltaTime = currentTime - state.lastTime
      state.lastTime = currentTime

      // Acumular el tiempo transcurrido
      state.accumulator += deltaTime

      // Fixed timestep: actualizar la lógica del juego a una tasa fija
      // Esto asegura que el juego funcione a la misma velocidad en todos los dispositivos
      while (state.accumulator >= FRAME_TIME) {
        update()
        state.accumulator -= FRAME_TIME
      }

      // Siempre dibujar (render) a la tasa de frames del dispositivo
      draw()
      requestAnimationFrame(loop)
    }

    // Escuchar evento para iniciar el juego
    window.addEventListener('start-game', () => {
      initRacerGame()
    })
  })()
</script>
